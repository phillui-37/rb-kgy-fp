module Fun
  def self.eq?: [T < Comparable, U < Comparable](T, U) -> bool

  def self.ne?: [T < Comparable, U < Comparable](T, U) -> bool

  def self.gt?: [T < Comparable, U < Comparable](T, U) -> bool

  def self.ge?: [T < Comparable, U < Comparable](T, U) -> bool

  def self.lt?: [T < Comparable, U < Comparable](T, U) -> bool

  def self.le?: [T < Comparable, U < Comparable](T, U) -> bool

  def self.id: [T](T) -> T

  def self.const: [T](T, untyped) -> T

  def self.pipe: [T, R](T, *^(untyped) -> untyped) -> R

  def self.compose: [T, R](T, *^(untyped) -> untyped) -> R

  def self.not?: (^(*untyped) -> untyped, *untyped) -> bool

  def self.nil_or: [T](optional[T], T) -> T

  def self.nil_or_else: [T](optional[T], ^-> T) -> T

  def self.not_nil_or: [T](optional[T], T) -> T

  def self.not_nil_or_else: [T](optional[T], ^-> T) -> T

  def self.not_nil_map: [T](nil, ^(T) -> untyped) -> nil
                      | [T, R](T, ^(T) -> R) -> R

  def self.add: [T](T, T) -> T

  def self.minus: [T](T, T) -> T

  def self.mul: [T](T, T) -> T

  def self.div: [T](T, T) -> T

  def self.mod: (Numeric, Numeric) -> Numeric

  def self.flip: [T, U, R](U, T, ^(T, U) -> R) -> R

  def self.all?: [T](T, *^(T) -> bool) -> bool

  def self.any?: [T](T, *^(T) -> bool) -> bool

  def self.clamp: [T < Comparable](T, T, T) -> T

  def self.cond: [T, R](Array[{cond: ^(T) -> bool, mapper: ^(T) -> R}], *T, **Hash[Symbol, T]) -> R

  def self.curry: [R](^(*untyped, **Hash[Symbol, untyped]) -> R) -> ^(*untyped, **Hash[Symbol, untyped]) -> (R | Proc)
end
